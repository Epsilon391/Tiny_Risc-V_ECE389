HEX 0 - 2

PIN_G18 ALU 1
PIN_F22
PIN_E17
PIN_L26
PIN_L25
PIN_J22
PIN_H22

PIN_M24 ALU 2
PIN_Y22
PIN_W21
PIN_W22
PIN_W25
PIN_U23
PIN_U24

PIN_AA25 RESULT
PIN_AA26
PIN_Y25
PIN_W26
PIN_Y26
PIN_W27
PIN_W28

PIN_V21 i
PIN_U21
PIN_AB20
PIN_AA21
PIN_AD24
PIN_AF23
PIN_Y19

PIN_AB19 memory
PIN_AA19
PIN_AG21
PIN_AH21
PIN_AE19
PIN_AF19
PIN_AE18


GLED
PIN_E21 PC
PIN_E22
PIN_E25
PIN_E24
PIN_H21
PIN_G20
PIN_G22
PIN_G21
PIN_F17

RLED instr
PIN_G19
PIN_F19
PIN_E19
PIN_F21
PIN_F18
PIN_E18
PIN_J19


cl7
PIN_AD18
PIN_AC18
PIN_AB18
PIN_AH19
PIN_AG19
PIN_AF18
PIN_AH18

PIN_AA17
PIN_AB16
PIN_AA16
PIN_AB17
PIN_AB15
PIN_AA15
PIN_AC17

allow custom in SW
PIN_AC27

p2 (16)
PIN_Y24

custom in (4-15)
PIN_AB27
PIN_AC26
PIN_AD26
PIN_AB26
PIN_AC25
PIN_AB25
PIN_AC24
PIN_AB24
PIN_AB23
PIN_AA24
PIN_AA23
PIN_AA22

ALU CTRL
PIN_H17
PIN_F15
PIN_G15
PIN_G16
PIN_H15



HEX7[0] PIN_AD17 Seven Segment Digit 7[0] Depending on JP6
HEX7[1] PIN_AE17 Seven Segment Digit 7[1] Depending on JP6
HEX7[2] PIN_AG17 Seven Segment Digit 7[2] Depending on JP6
HEX7[3] PIN_AH17 Seven Segment Digit 7[3] Depending on JP6
HEX7[4] PIN_AF17 Seven Segment Digit 7[4] Depending on JP6
HEX7[5] PIN_AG18 Seven Segment Digit 7[5] Depending on JP6
HEX7[6] PIN_AA14 Seven Segment Digit 7[6] 3.3V

### (4.3) Register-Immediate Arithmetic Instructions
    imm    | rs1 |000| rd  |0010011
addi 1 + 0 = 1 (1)
000000000001 00000 000 10000 0010011

ori 11 | 00 = 11 (3)
000000000011 00000 110 10001 0010011

andi 01 & 11 = 01 (1)
000000000001 10001 111 10010 0010011

xori 01 ^ 11 = 10 (2)
000000000001 10001 100 10011 0010011


PC = 0-3 complete
ADDRS  VALUE
10000 = (1)
10001 = (3)
10010 = (1)
10011 = (2)


### (4.2) Register-Register Arithmetic Instructions
0000000| rs2 | rs1 |000| rd  |0110011

add 10 + 11 = 101 (5)
0000000 10011 10001 000 10100 0110011

sub 1 - 10 = 11..11 (-1)
0100000 10011 10000 000 10101 0110011

sub 11 - 1 = 11..10 (-2)
0100000 10001 10010 000 11010 0110011

and 011 & 101 = 001 (1)
0000000 10001 10100 111 10110 0110011

or 011 | 101 = 111 (7)
0000000 10001 10100 110 10111 0110011

xor 011 ^ 101 = 110 (6)
0000000 10001 10100 000 11000 0110011

PC = 4-9 complete
ADDRS  VALUE
10000 = (1)
10001 = (3)
10010 = (1)
10011 = (2)
10100 = (5)
10101 = (-1)
11010 = (-2)
10110 = (1)
10111 = (7)
11000 = (6)

slt 10 < 11 = true
0000000 10001 10011 010 11001 0110011

slt 10 (2)<(-1) 11..11 = false
0000000 10101 10011 010 11001 0110011

slt 11..11 (-1)<(3) 11 = true
0000000 10001 10101 010 11001 0110011

slt 11..10 (-2)<(-1) 11..11 = true
0000000 10101 11010 010 11001 0110011

sltu 10 < 11 = true
0000000 10001 10011 011 11001 0110011

sltu 10 < 11..11 = true
0000000 10101 10011 011 11001 0110011

sltu 11..11 < 11 = false
0000000 10001 10101 011 11001 0110011

sltu 11..10 < 11..11 = true
0000000 10101 11010 011 11001 0110011

mul (2) * (5) = (10)
0000001 10011 10100 000 11010 0110011

mul (3) * (10) = (30) displays (14 e)
0000001 11010 10001 000 11010 0110011


 imm | rd | 0110111 
LUI
10000000000000000000 11011 0110111

AUIPC (21)+10..00 << (12) displays: (5)
10000000000000000000 11101 0010111

sra 10..00 >>> 30 = 11..110 displays:(14 e)
0100000 11010 11011 101 11100 0110011

srl 10..00 >> 30 = 00..0010 (2)
0000000 11010 11011 101 11100 0110011

sll 110 << 1 = 1100 (12)
0000000 10000 11000 001 11100 0110011

PC = 10-24 complete
ADDRS  VALUE
10000 = (1)
10001 = (3)
10010 = (1)
10011 = (2)
10100 = (5)
10101 = (-1)
11010 = (-2)
10110 = (1)
10111 = (7)
11000 = (6)
11001 = (1)
11010 = (30)
11011 = 10..00
11100 = (12)
11101 = (21)+10..00 << (12)


SLTI (-1) <s (1) = true
000000000001 10101 010 11001 0010011

SLTIU 1..1 <s 1 = false
000000000001 10101 011 11001 0010011
********************************************************
0x00000| imm | rs1 |x01| rd  |0010011 
SRAI 10..00 >>> 30 = 11..110 displays:(14 e)
0100000 11110 11011 101 11100 0010011

SRLI 10..0..010101 >> 3 = 00010..0010/101\ (2)
0000000 00011 11101 101 11100 0010011
*************************************************************
SLLI 110 << 1 = 1100 (12)
0000000 00001 11000 001 11100 0010011


PC = 25-29 complete
ADDRS  VALUE
10000 = (1)
10001 = (3)
10010 = (1)
10011 = (2)
10100 = (5)
10101 = (-1)
11010 = (-2)
10110 = (1)
10111 = (7)
11000 = (6)
11001 = (0)
11010 = (30)
11011 = 10..00
11100 = (12)
11101 = (21)+10..00 << (12)


 imm | rs2 | rs1 | 010 | imm | 0100011
SW store (6) into memory 1+1=2 
0000000 11000 10000 010 00001 0100011

 imm | rs1 | 010 | rd | 0000011 
LW read from mem 1+1=2, store in reg 16  
000000000001 10000 010 10000 0000011

PC = 30-31 complete
ADDRS  VALUE
10000 = (6)
10001 = (3)
10010 = (1)
10011 = (2)
10100 = (5)
10101 = (-1)
11010 = (-2)
10110 = (1)
10111 = (7)
11000 = (6)
11001 = (0)
11010 = (30)
11011 = 10..00
11100 = (12)
11101 = (21)+10..00 << (12)

PC=32
 imm | rd | 1101111 
JAL jump to 34, place 33 into ra
00000000000000000010 00010 1101111

addi 10 + 0 = 10 (2) SKIPED until branch
000000000010 00000 000 10001 0010011

PC=34
addi 110 + 0 = 110 (6)
000000000000 10000 000 10000 0010011

PC=35
 imm | rs2 | rs1 | 000 | imm | 1100011 
beq jump to 37 if eq
0000010 10001 10011 000 00000 1100011

 000000000000 | rs1 | 000 | 00000 | 1100111 
JR jump to ra (33), branch will now be satisfied
000000000000 00010 000 00000 1100111

PC=37
branch satisfied
imm | rs1 | 000 | rd | 1100111 
JALR jump to 39 and store 38 in rd
000000100111 00000 000 00010 1100111

PC=38
addi 10 + 0 = 10 (2) SKIPED
000000000010 00000 000 10001 0010011 

PC=39
addi ra + 0 = 100110 (38), displays (6)
000000000000 00010 000 10000 0010011







recursion



addi for user input to reg 16
000000000011 00000 000 10000 0010011

addi 1 into reg 20
000000000001 00000 000 10100 0010011

addi 1 into reg 21
000000000001 00000 000 10101 0010011

inc reg 18 by 1
000000000001 10010 000 11111 0010011
000000000000 11111 000 10010 0010011

jal to PC = 8
00000000000000000011 00010 1101111

jal to 21
00000000000000001111 00010 1101111


PC=8
SW ra at mem at reg 18
0000000 00010 10010 010 00000 0100011

inc reg 18 by 1
000000000001 10010 000 11111 0010011
000000000000 11111 000 10010 0010011

PC=11, branch to 17
bge reg 17, reg 16
0000110 10000 10001 101 00000 1100011 *

PC=12
reg 17 += 1
000000000001 10001 000 11111 0010011
000000000000 11111 000 10001 0010011

PC=14
mult reg 20, reg 17
0000001 10001 10100 000 11111 0110011 *
000000000000 11111 000 10100 0010011  *

PC=16
jal to pc=8
11111111111111111000 00010 1101111 *

PC=17
dec reg 18 by 1
0100000 10101 10010 000 11111 0110011
000000000000 11111 000 10010 0010011

PC=19
LW from mem at reg 18 into ra
000000000000 10010 010 00010 0000011

PC=20
jump to ra (should be pc=4 after a while)
000000000000 00010 000 00000 1100111

breakpoint
00000000000000000000000001111111

PC=22
addi 0 to reg 20 for result
000000000000 10100 000 11000 0010011




